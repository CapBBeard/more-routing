<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="more-routing.html">

<polymer-element name="more-route">
  <script>
  (function() {
    // The set of properties that are bound by proxied routes.
    var PROXIED_PROPERTIES = ['route', 'fullRoute', 'params', 'active'];

    Polymer('more-route', {
      publish: {
        /**
         * A routing expression used to parse parameters from the window's URL.
         *
         * @attribute route
         * @type String
         */
        route: '',

        /**
         * A unique name for this route, or the name of a route to proxy (if no
         * `route` expression is given).
         *
         * NOTE: Named routes are only evaluated when the element is created!
         * Call `MoreRouting.registerNamedRoute` if you need to do something
         * more dynamic.
         *
         * @attribute name
         * @type String
         */
        name: '',

        /**
         * The complete route, including routes that this is contained by.
         *
         * @attribute fullRoute
         * @type String
         */
        fullRoute: '',

        /**
         * The exposed parameters that were read from the URL.
         *
         * @attribute params
         * @type Object
         */
        params: {},

        /**
         * Whether the route matches the current URL.
         *
         * @attribute active
         * @type Boolean
         */
        active: false,

        /**
         * Whether this route is a proxy to the primary route with the same
         * `name`.
         *
         * Defaults to `true` when `name` is set, but `route` is not.
         *
         * @attribute proxy
         * @type Boolean
         */
        proxy: false,
      },

      /**
       * Convert `params` into the URL they represent for this route.
       *
       * @method urlFor
       * @param params Object
       */
      urlFor: function(params) {
        return this._partsForParams(params).join('/');
      },

      /**
       * Navigates to the URL represented by `params`.
       *
       * @method navigateTo
       * @param params Object
       */
      navigateTo: function(params) {
        MoreRouting.adaptor.navigateTo(this.urlFor(params));
      },

      /**
       * Whether `params` matches this route **and** the current URL.
       *
       * @method isCurrentUrl
       * @param params Object
       */
      isCurrentUrl: function(params) {
        if (!this.active) return;
        var compiled = this._compiledRoute();
        var current  = MoreRouting.adaptor.currentPathParts;
        // Prefixes are ok.
        if (compiled.length > current.length) return false;

        for (var i = 0, config; config = compiled[i]; i++) {
          if (config.match !== true && config.match !== current[i]) {
            return false;
          }
          if (config.param && params[config.param] !== current[i]) {
            return false;
          }
          // And ignore wildcards.
        }

        return true;
      },

      // Lifecycle

      ready: function() {
        this._doEvaluate = this._evaluate.bind(this);
        if (this.name && this.route) {
          MoreRouting.registerNamedRoute(this);
        }
      },

      // Observers

      nameChanged: function() {
        this._identityChanged();
      },

      routeChanged: function() {
        if (this.proxy) return;
        this._identityChanged();

        if (this.route) {
          var routes = this._routeAncestry().map(function(a) {return a.route});
          this.fullRoute = routes.join('/').replace(/\/+/g, '/');
          this._compiled = MoreRouting.compileExpression(this.fullRoute);
          MoreRouting.adaptor.register(this._compiled, this._doEvaluate);
        } else {
          MoreRouting.adaptor.unregister(this._compiled, this._doEvaluate);
          this._compiled = null;
        }
      },

      // Adaptor Workflow

      _evaluate: function(pathParts) {
        if (this.proxy) {
          throw new Error('Bug! Proxy route got route update callback');
        }

        this.active = !!pathParts;
        this.params = {};
        if (!pathParts) return;

        for (var i = 0, config; config = this._compiled[i]; i++) {
          if (config.param) {
            this.params[config.param] = pathParts[i];
          }
        }
      },

      // Named Route Proxying

      _identityChanged: function() {
        this.proxy = this.name && !this.route;
        this.proxy ? this._bindToNamedRoute() : this._unbindFromNamedRoute();
      },

      _bindToNamedRoute: function() {
        var namedRoute = MoreRouting.getNamedRoute(this.name);
        this._namedRouteBindings = PROXIED_PROPERTIES.map(function(property) {
          this.bind(property, new PathObserver(namedRoute, property));
        }.bind(this));
      },

      _unbindFromNamedRoute: function() {
        if (!this._namedRouteBindings) return;
        for (var i = 0, binding; binding = this._namedRouteBindings[i]; i++) {
          binding.close();
        }
      },

      // Utility

      // Includes this.
      _routeAncestry: function() {
        var ancestry = [];
        var node = this;
        while (node) {
          var route = node.containsRoute || node;
          // TODO(nevir): Is this safe x-plat/polyfill?
          if (route instanceof this.constructor) {
            ancestry.unshift(route);
          }

          node = node.parentNode || node.host;
        }

        return ancestry;
      },

      _compiledRoute: function() {
        return this._compiled || MoreRouting.getNamedRoute(this.name)._compiled;
      },

      _partsForParams: function(params) {
        var parts = this._compiledRoute().map(function(config) {
          if (config.param) {
            if (!params[config.param]) {
              throw new Error('param "' + config.param + '" is required for route: ' + this.route);
            }
            return params[config.param];

          // TODO(nevir): Wildcards aren't very well supported. Fix that.
          } else if (config.match === true) {
            return '';
          } else {
            return config.match;
          }
        });

        return parts;
      },
    });
  })();
  </script>
</polymer-element>
