<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="more-routing.html">

<polymer-element name="more-route">
  <script>
  (function() {
    // The set of properties that are bound by proxied routes.
    var PROXIED_PROPERTIES = ['route', 'fullRoute', 'params', 'active'];

    Polymer('more-route', {
      publish: {
        /**
         * A routing expression used to parse parameters from the window's URL.
         *
         * @attribute route
         * @type String
         */
        route: '',

        /**
         * A unique name for this route, or the name of a route to proxy (if no
         * `route` expression is given).
         *
         * NOTE: Named routes are only evaluated when the element is created!
         * Call `MoreRouting.registerNamedRoute` if you need to do something
         * more dynamic.
         *
         * @attribute name
         * @type String
         */
        name: '',

        /**
         * The complete route, including routes that this is contained by.
         *
         * @attribute fullRoute
         * @type String
         */
        fullRoute: '',

        /**
         * The exposed parameters that were read from the URL.
         *
         * @attribute params
         * @type Object
         */
        params: {},

        /**
         * Whether the route matches the current URL.
         *
         * @attribute active
         * @type Boolean
         */
        active: false,

        /**
         * Whether this route is a proxy to the primary route with the same
         * `name`.
         *
         * Defaults to `true` when `name` is set, but `route` is not.
         *
         * @attribute proxy
         * @type Boolean
         */
        proxy: false,
      },

      // Lifecycle

      ready: function() {
        this._doEvaluate = this._evaluate.bind(this);
        if (this.name && this.route) {
          MoreRouting.registerNamedRoute(this);
        }
      },

      // Observers

      nameChanged: function() {
        this._identityChanged();
      },

      routeChanged: function() {
        if (this.proxy) return;
        this._identityChanged();

        if (this.route) {
          var routes = this._routeAncestry().map(function(a) {return a.route});
          this.fullRoute = routes.join('/').replace(/\/+/g, '/');
          this._compiled = MoreRouting.compileExpression(this.fullRoute);
          MoreRouting.adaptor.register(this._compiled, this._doEvaluate);
        } else {
          MoreRouting.adaptor.unregister(this._compiled, this._doEvaluate);
          this._compiled = null;
        }
      },

      // Adaptor Workflow

      _evaluate: function(pathParts) {
        if (this.proxy) {
          throw new Error('Bug! Proxy route got route update callback');
        }

        this.active = !!pathParts;
        this.params = {};
        if (!pathParts) return;

        for (var i = 0, config; config = this._compiled[i]; i++) {
          if (config.param) {
            this.params[config.param] = pathParts[i];
          }
        }
      },

      // Named Route Proxying

      _identityChanged: function() {
        this.proxy = this.name && !this.route;
        this.proxy ? this._bindToNamedRoute() : this._unbindFromNamedRoute();
      },

      _bindToNamedRoute: function() {
        var namedRoute = MoreRouting.getNamedRoute(this.name);
        this._namedRouteBindings = PROXIED_PROPERTIES.map(function(property) {
          this.bind(property, new PathObserver(namedRoute, property));
        }.bind(this));
      },

      _unbindFromNamedRoute: function() {
        if (!this._namedRouteBindings) return;
        for (var i = 0, binding; binding = this._namedRouteBindings[i]; i++) {
          binding.close();
        }
      },

      // Nesting

      // Includes this.
      _routeAncestry: function() {
        var ancestry = [];
        var node = this;
        while (node) {
          var route = node.containsRoute || node;
          // TODO(nevir): Is this safe x-plat/polyfill?
          if (route instanceof this.constructor) {
            ancestry.unshift(route);
          }

          node = node.parentNode || node.host;
        }

        return ancestry;
      },
    });
  })();
  </script>
</polymer-element>
